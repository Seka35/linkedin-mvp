# üöÄ PROTOTYPE MVP - LINKEDIN AUTOMATION

## üìã PLAN D'EX√âCUTION PAR PHASES

**Objectif :** Cr√©er un prototype simple, gratuit, fonctionnel en Python avec interface web basique pour automatiser LinkedIn (scraping + connexions + commentaires + DMs).

---

# PHASE 4 : BOT LINKEDIN (PLAYWRIGHT avec Cookie)

## Objectif
Cr√©er un bot LinkedIn avec Playwright utilisant le cookie de session `li_at` pour √©viter les logins r√©p√©t√©s et r√©duire les d√©tections.

## Instructions pour l'IA

### 4.1 Cr√©er `services/proxy_manager.py` :

```python
"""
Gestion des proxies (optionnel pour MVP).
"""

import os

class ProxyManager:
    """Gestionnaire de proxies"""
    
    def __init__(self):
        self.proxy_url = os.getenv('PROXY_URL')
        self.proxy_username = os.getenv('PROXY_USERNAME')
        self.proxy_password = os.getenv('PROXY_PASSWORD')
    
    def get_proxy_config(self) -> dict:
        """Retourner config proxy pour Playwright"""
        if not self.proxy_url:
            return None
        
        return {
            'server': self.proxy_url,
            'username': self.proxy_username,
            'password': self.proxy_password
        }
```

### 4.2 Cr√©er `services/linkedin_bot.py` (VERSION COOKIE) :

```python
"""
Bot LinkedIn utilisant Playwright avec authentification par cookie.
Plus s√ªr et plus rapide que login email/password.
"""

from playwright.sync_api import sync_playwright, Page, Browser
import os
import time
import random
import json
from .proxy_manager import ProxyManager

class LinkedInBot:
    """Bot d'automatisation LinkedIn avec authentification cookie"""
    
    def __init__(self, headless: bool = True):
        self.li_at_cookie = os.getenv('LINKEDIN_LI_AT_COOKIE')
        self.headless = headless
        self.proxy_manager = ProxyManager()
        
        self.playwright = None
        self.browser = None
        self.context = None
        self.page = None
        
        if not self.li_at_cookie:
            raise ValueError("‚ùå LINKEDIN_LI_AT_COOKIE non configur√© dans .env")
    
    def start(self):
        """D√©marrer le navigateur avec cookie de session"""
        print("üöÄ D√©marrage du bot LinkedIn (mode cookie)...")
        
        self.playwright = sync_playwright().start()
        
        # Configuration proxy
        proxy_config = self.proxy_manager.get_proxy_config()
        
        # Lancer navigateur
        self.browser = self.playwright.chromium.launch(
            headless=self.headless,
            proxy=proxy_config
        )
        
        # Cr√©er contexte avec fingerprinting
        self.context = self.browser.new_context(
            viewport={'width': 1920, 'height': 1080},
            user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            locale='fr-FR',
            timezone_id='Europe/Paris'
        )
        
        # Injecter le cookie de session LinkedIn
        self._inject_cookie()
        
        self.page = self.context.new_page()
        
        # V√©rifier que le cookie fonctionne
        self._verify_session()
        
        print("‚úÖ Bot d√©marr√© et authentifi√© via cookie")
    
    def stop(self):
        """Arr√™ter le navigateur"""
        if self.browser:
            self.browser.close()
        if self.playwright:
            self.playwright.stop()
        print("üõë Bot arr√™t√©")
    
    def _inject_cookie(self):
        """Injecter le cookie li_at dans le contexte du navigateur"""
        cookie = {
            'name': 'li_at',
            'value': self.li_at_cookie,
            'domain': '.linkedin.com',
            'path': '/',
            'httpOnly': True,
            'secure': True,
            'sameSite': 'None'
        }
        
        self.context.add_cookies([cookie])
        print("üç™ Cookie li_at inject√©")
    
    def _verify_session(self):
        """V√©rifier que la session est valide"""
        print("üîê V√©rification de la session...")
        
        self.page.goto('https://www.linkedin.com/feed/', wait_until='networkidle')
        time.sleep(3)
        
        # V√©rifier qu'on est bien connect√© (pr√©sence du feed)
        if '/feed' in self.page.url or '/mynetwork' in self.page.url:
            print("‚úÖ Session valide, connect√© √† LinkedIn")
        else:
            # Si on est redirig√© vers /login, le cookie est invalide
            if '/login' in self.page.url or '/uas' in self.page.url:
                raise Exception("‚ùå Cookie invalide ou expir√©. Reconnectez-vous manuellement et r√©cup√©rez un nouveau cookie.")
            else:
                print("‚ö†Ô∏è √âtat de connexion incertain, continuer avec prudence")
    
    def visit_profile(self, profile_url: str) -> bool:
        """
        Visiter un profil LinkedIn.
        
        Args:
            profile_url: URL du profil
        
        Returns:
            True si succ√®s
        """
        try:
            print(f"üëÅÔ∏è Visite du profil: {profile_url}")
            
            self.page.goto(profile_url, wait_until='networkidle')
            
            # Simuler comportement humain
            self._random_delay(3, 6)
            self._scroll_page()
            
            return True
            
        except Exception as e:
            print(f"‚ùå Erreur visite profil: {e}")
            return False
    
    def send_connection_request(self, profile_url: str, message: str = "") -> bool:
        """
        Envoyer une demande de connexion.
        
        Args:
            profile_url: URL du profil
            message: Message personnalis√© (optionnel, max 300 char)
        
        Returns:
            True si succ√®s
        """
        try:
            print(f"ü§ù Envoi demande de connexion: {profile_url}")
            
            # Visiter le profil d'abord
            self.page.goto(profile_url, wait_until='networkidle')
            self._random_delay(2, 4)
            
            # Cliquer sur bouton "Se connecter" / "Connect"
            # Plusieurs s√©lecteurs possibles selon la langue et la version de LinkedIn
            connect_selectors = [
                'button:has-text("Connect")',
                'button:has-text("Se connecter")',
                'button.pvs-profile-actions__action:has-text("Connect")',
                'button.pvs-profile-actions__action:has-text("Se connecter")',
            ]
            
            connect_button = None
            for selector in connect_selectors:
                try:
                    connect_button = self.page.locator(selector).first
                    if connect_button.is_visible(timeout=2000):
                        break
                except:
                    continue
            
            if not connect_button or not connect_button.is_visible():
                print("‚ö†Ô∏è Bouton 'Connect' non trouv√© (d√©j√† connect√© ou profil priv√©)")
                return False
            
            connect_button.click()
            self._random_delay(1, 2)
            
            # Si message personnalis√©
            if message:
                try:
                    # Cliquer "Ajouter une note" / "Add a note"
                    add_note_selectors = [
                        'button:has-text("Add a note")',
                        'button:has-text("Ajouter une note")',
                    ]
                    
                    for selector in add_note_selectors:
                        try:
                            add_note = self.page.locator(selector).first
                            if add_note.is_visible(timeout=2000):
                                add_note.click()
                                self._random_delay(1, 2)
                                break
                        except:
                            continue
                    
                    # √âcrire le message
                    textarea = self.page.locator('textarea[name="message"], textarea#custom-message').first
                    if textarea.is_visible(timeout=2000):
                        textarea.fill(message[:300])  # Max 300 caract√®res
                        self._random_delay(1, 2)
                except Exception as e:
                    print(f"‚ö†Ô∏è Impossible d'ajouter une note: {e}")
            
            # Envoyer la demande
            send_selectors = [
                'button:has-text("Send")',
                'button:has-text("Envoyer")',
                'button[aria-label="Send invitation"]',
                'button[aria-label="Envoyer l\'invitation"]',
            ]
            
            for selector in send_selectors:
                try:
                    send_button = self.page.locator(selector).first
                    if send_button.is_visible(timeout=2000):
                        send_button.click()
                        break
                except:
                    continue
            
            print("‚úÖ Demande de connexion envoy√©e")
            self._random_delay(2, 4)
            return True
                
        except Exception as e:
            print(f"‚ùå Erreur envoi connexion: {e}")
            return False
    
    def comment_on_post(self, post_url: str, comment: str) -> bool:
        """
        Commenter sur un post LinkedIn.
        
        Args:
            post_url: URL du post
            comment: Texte du commentaire
        
        Returns:
            True si succ√®s
        """
        try:
            print(f"üí¨ Commentaire sur post: {post_url}")
            
            self.page.goto(post_url, wait_until='networkidle')
            self._random_delay(2, 4)
            
            # Cliquer sur la zone de commentaire
            comment_box_selectors = [
                '.ql-editor[contenteditable="true"]',
                '[contenteditable="true"].ql-editor',
                'div.ql-editor',
            ]
            
            comment_box = None
            for selector in comment_box_selectors:
                try:
                    comment_box = self.page.locator(selector).first
                    if comment_box.is_visible(timeout=2000):
                        break
                except:
                    continue
            
            if not comment_box:
                print("‚ö†Ô∏è Zone de commentaire non trouv√©e")
                return False
            
            comment_box.click()
            self._random_delay(1, 2)
            
            # √âcrire le commentaire
            comment_box.fill(comment)
            self._random_delay(2, 3)
            
            # Cliquer sur "Publier" / "Post"
            post_selectors = [
                'button:has-text("Post")',
                'button:has-text("Publier")',
                'button.comments-comment-box__submit-button',
            ]
            
            for selector in post_selectors:
                try:
                    post_button = self.page.locator(selector).first
                    if post_button.is_visible(timeout=2000):
                        post_button.click()
                        break
                except:
                    continue
            
            print("‚úÖ Commentaire publi√©")
            self._random_delay(2, 4)
            return True
            
        except Exception as e:
            print(f"‚ùå Erreur commentaire: {e}")
            return False
    
    def send_message(self, profile_url: str, message: str) -> bool:
        """
        Envoyer un message direct (DM).
        
        Args:
            profile_url: URL du profil
            message: Message √† envoyer
        
        Returns:
            True si succ√®s
        """
        try:
            print(f"üíå Envoi message: {profile_url}")
            
            # Aller sur le profil
            self.page.goto(profile_url, wait_until='networkidle')
            self._random_delay(2, 4)
            
            # Cliquer sur "Message"
            message_button_selectors = [
                'button:has-text("Message")',
                'button:has-text("Envoyer un message")',
                'button.pvs-profile-actions__action:has-text("Message")',
            ]
            
            message_button = None
            for selector in message_button_selectors:
                try:
                    message_button = self.page.locator(selector).first
                    if message_button.is_visible(timeout=2000):
                        break
                except:
                    continue
            
            if not message_button or not message_button.is_visible():
                print("‚ö†Ô∏è Bouton 'Message' non disponible (pas encore connect√©?)")
                return False
            
            message_button.click()
            self._random_delay(2, 3)
            
            # √âcrire le message dans la bo√Æte de dialogue
            message_box_selectors = [
                '.msg-form__contenteditable[contenteditable="true"]',
                'div[contenteditable="true"].msg-form__contenteditable',
                'div.msg-form__contenteditable',
            ]
            
            message_box = None
            for selector in message_box_selectors:
                try:
                    message_box = self.page.locator(selector).last
                    if message_box.is_visible(timeout=3000):
                        break
                except:
                    continue
            
            if not message_box:
                print("‚ö†Ô∏è Bo√Æte de message non trouv√©e")
                return False
            
            message_box.click()
            self._random_delay(0.5, 1)
            message_box.fill(message)
            self._random_delay(1, 2)
            
            # Envoyer
            send_selectors = [
                'button:has-text("Send")',
                'button:has-text("Envoyer")',
                'button.msg-form__send-button',
            ]
            
            for selector in send_selectors:
                try:
                    send_button = self.page.locator(selector).last
                    if send_button.is_visible(timeout=2000):
                        send_button.click()
                        break
                except:
                    continue
            
            print("‚úÖ Message envoy√©")
            self._random_delay(2, 4)
            return True
                
        except Exception as e:
            print(f"‚ùå Erreur envoi message: {e}")
            return False
    
    def _random_delay(self, min_sec: float = 2, max_sec: float = 5):
        """D√©lai al√©atoire pour simuler comportement humain"""
        delay = random.uniform(min_sec, max_sec)
        time.sleep(delay)
    
    def _scroll_page(self):
        """Scroller la page pour simuler lecture"""
        try:
            self.page.evaluate("""
                window.scrollTo({
                    top: Math.random() * document.body.scrollHeight / 2,
                    behavior: 'smooth'
                });
            """)
            self._random_delay(1, 3)
        except:
            pass
    
    def save_cookies(self, filepath: str = 'cookies.json'):
        """
        Sauvegarder les cookies de session (optionnel, pour backup).
        
        Args:
            filepath: Chemin du fichier de sauvegarde
        """
        cookies = self.context.cookies()
        with open(filepath, 'w') as f:
            json.dump(cookies, f, indent=2)
        print(f"‚úÖ Cookies sauvegard√©s dans {filepath}")
    
    def load_cookies(self, filepath: str = 'cookies.json'):
        """
        Charger des cookies depuis un fichier (optionnel).
        
        Args:
            filepath: Chemin du fichier de cookies
        """
        try:
            with open(filepath, 'r') as f:
                cookies = json.load(f)
            self.context.add_cookies(cookies)
            print(f"‚úÖ Cookies charg√©s depuis {filepath}")
        except FileNotFoundError:
            print(f"‚ö†Ô∏è Fichier {filepath} non trouv√©")
```

### 4.3 Mettre √† jour `.env.example` :

```bash
# LinkedIn Authentication (COOKIE)
# Pour r√©cup√©rer votre cookie li_at:
# 1. Connectez-vous √† LinkedIn dans votre navigateur
# 2. Ouvrir DevTools (F12) > Application/Stockage > Cookies
# 3. Trouver le cookie "li_at" sur linkedin.com
# 4. Copier sa valeur compl√®te ici
LINKEDIN_LI_AT_COOKIE=votre-cookie-li-at-ici

# Ancienne m√©thode (ne plus utiliser)
# LINKEDIN_EMAIL=your-email@example.com
# LINKEDIN_PASSWORD=your-password

# Proxy Configuration (optionnel pour MVP)
PROXY_URL=
PROXY_USERNAME=
PROXY_PASSWORD=

# Apify API (gratuit 5$/mois)
APIFY_API_KEY=your-apify-key

# Google SERP API (optionnel, ou scraping direct)
SERP_API_KEY=

# Flask
FLASK_SECRET_KEY=change-this-to-random-string
FLASK_ENV=development
```

### 4.4 Cr√©er un script helper pour r√©cup√©rer le cookie :

**Fichier: `scripts/get_linkedin_cookie.py`**

```python
"""
Script helper pour r√©cup√©rer facilement le cookie LinkedIn li_at.
"""

from playwright.sync_api import sync_playwright
import time

def get_linkedin_cookie():
    """Ouvrir LinkedIn et attendre que l'utilisateur se connecte pour extraire le cookie"""
    
    print("=" * 60)
    print("üç™ R√âCUP√âRATION DU COOKIE LINKEDIN")
    print("=" * 60)
    print("\nInstructions:")
    print("1. Une fen√™tre de navigateur va s'ouvrir")
    print("2. Connectez-vous √† LinkedIn normalement")
    print("3. Une fois connect√©, le cookie sera extrait automatiquement")
    print("4. Copiez le cookie affich√© dans votre fichier .env")
    print("\nAppuyez sur Entr√©e pour continuer...")
    input()
    
    with sync_playwright() as p:
        # Lancer navigateur (non-headless pour voir)
        browser = p.chromium.launch(headless=False)
        context = browser.new_context(
            viewport={'width': 1920, 'height': 1080}
        )
        page = context.new_page()
        
        # Aller sur LinkedIn
        print("\nüåê Ouverture de LinkedIn...")
        page.goto('https://www.linkedin.com/login')
        
        print("\n‚è≥ En attente de votre connexion...")
        print("   Connectez-vous dans le navigateur qui s'est ouvert")
        print("   (Le script attend max 120 secondes)")
        
        # Attendre que l'utilisateur se connecte (max 2 minutes)
        try:
            page.wait_for_url('**/feed/**', timeout=120000)
            print("\n‚úÖ Connexion d√©tect√©e!")
            
            # R√©cup√©rer tous les cookies
            cookies = context.cookies()
            
            # Trouver le cookie li_at
            li_at_cookie = None
            for cookie in cookies:
                if cookie['name'] == 'li_at':
                    li_at_cookie = cookie['value']
                    break
            
            if li_at_cookie:
                print("\n" + "=" * 60)
                print("‚úÖ COOKIE R√âCUP√âR√â AVEC SUCC√àS!")
                print("=" * 60)
                print("\nCopiez cette ligne dans votre fichier .env :\n")
                print(f"LINKEDIN_LI_AT_COOKIE={li_at_cookie}")
                print("\n" + "=" * 60)
                print("\n‚ö†Ô∏è  IMPORTANT:")
                print("   - Ce cookie expire g√©n√©ralement apr√®s 1 an")
                print("   - Ne le partagez jamais publiquement")
                print("   - Gardez-le dans .env (qui est dans .gitignore)")
                print("=" * 60)
            else:
                print("\n‚ùå Cookie li_at non trouv√©")
                print("   V√©rifiez que vous √™tes bien connect√© √† LinkedIn")
            
        except Exception as e:
            print(f"\n‚ùå Erreur ou timeout: {e}")
            print("   Relancez le script et connectez-vous plus rapidement")
        
        finally:
            print("\nFermeture du navigateur dans 5 secondes...")
            time.sleep(5)
            browser.close()

if __name__ == '__main__':
    get_linkedin_cookie()
```

### 4.5 Mettre √† jour `main.py` pour v√©rifier le cookie :

```python
"""
Point d'entr√©e principal de l'application LinkedIn MVP.
"""

import os
from dotenv import load_dotenv

# Charger variables d'environnement
load_dotenv()

# V√©rifier que le cookie LinkedIn est pr√©sent
if not os.getenv('LINKEDIN_LI_AT_COOKIE'):
    print("‚ùå ERREUR: LINKEDIN_LI_AT_COOKIE doit √™tre configur√© dans .env")
    print("\nüìñ Pour r√©cup√©rer votre cookie:")
    print("   1. Lancez: python scripts/get_linkedin_cookie.py")
    print("   2. Connectez-vous √† LinkedIn dans le navigateur qui s'ouvre")
    print("   3. Copiez le cookie affich√© dans votre .env")
    print("")
    exit(1)

# Initialiser la base de donn√©es
from database import init_db
init_db()

# Lancer l'application Flask
from web.app import app

if __name__ == '__main__':
    print("üöÄ D√©marrage de LinkedIn Automation MVP...")
    print("üìç Acc√®s: http://localhost:5000")
    print("")
    print("‚úÖ Authentification: Cookie li_at")
    print("")
    print("‚ö†Ô∏è  ATTENTION:")
    print("  - Utilisez ce bot de mani√®re responsable")
    print("  - Respectez les limites (10-20 actions/jour max)")
    print("  - Risque de ban LinkedIn en cas d'abus")
    print("")
    
    app.run(debug=True, host='0.0.0.0', port=5000)
```

### 4.6 Mettre √† jour le README avec instructions cookie :

**Ajout dans README.md (section Installation) :**

```markdown
## üç™ R√©cup√©ration du Cookie LinkedIn

Au lieu d'utiliser email/password, on utilise le cookie de session `li_at` qui est plus s√ªr et √©vite les d√©tections.

### M√©thode automatique (recommand√©e)

```bash
python scripts/get_linkedin_cookie.py
```

1. Un navigateur s'ouvre
2. Connectez-vous √† LinkedIn normalement
3. Le script extrait automatiquement le cookie
4. Copiez-le dans votre `.env`

### M√©thode manuelle

1. Connectez-vous √† LinkedIn dans Chrome/Firefox
2. Ouvrir DevTools (F12)
3. Onglet "Application" (Chrome) ou "Stockage" (Firefox)
4. Section "Cookies" > `https://www.linkedin.com`
5. Trouver le cookie nomm√© `li_at`
6. Copier sa **valeur compl√®te**
7. Coller dans `.env`:

```bash
LINKEDIN_LI_AT_COOKIE=AQEDATXXXXXXxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
```

### ‚ö†Ô∏è S√©curit√© du Cookie

- **Dur√©e de validit√©:** ~1 an
- **Ne jamais partager** ce cookie (acc√®s complet √† votre compte)
- **Garder dans .env** (d√©j√† dans .gitignore)
- Si compromis, d√©connectez-vous de LinkedIn pour l'invalider

### Avantages du Cookie vs Email/Password

‚úÖ Pas de login √† chaque d√©marrage
‚úÖ Moins de d√©tection par LinkedIn
‚úÖ Plus rapide (skip la page de login)
‚úÖ Pas de probl√®me avec 2FA
‚úÖ M√™me session que votre navigateur principal
```

## Livrables de Phase 4 (VERSION COOKIE)
- [ ] Bot LinkedIn avec authentification cookie cr√©√©
- [ ] Fonction `_inject_cookie()` pour injecter le cookie
- [ ] Fonction `_verify_session()` pour valider le cookie
- [ ] Script helper `get_linkedin_cookie.py` pour r√©cup√©rer le cookie
- [ ] Fonction `visit_profile()` impl√©ment√©e
- [ ] Fonction `send_connection_request()` avec message optionnel
- [ ] Fonction `comment_on_post()` impl√©ment√©e
- [ ] Fonction `send_message()` (DM) impl√©ment√©e
- [ ] D√©lais al√©atoires et simulation comportement humain
- [ ] Documentation README mise √† jour